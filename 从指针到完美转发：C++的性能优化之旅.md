# 从右值到完美转发：C++的性能优化之旅

## 右值与左值

在C++98里，我们使用**有没有实体**来区别左值与右值，像下面这种变量a，它实际上是在内存中有一个区域来存储它的，所以我们称之为左值，1是一个字面量，存在寄存器中，没有不算一个实体，因为没有独属于它的空间，这个寄存器随时可以存储下一个值，所以叫右值。
```c++
int a = 1;
```
所以左值可以取地址：

```c++
int *ptr = &a;
```
但是右值不行：
```c++
int *ptr = &1;
```
## 移动语义

C++里的赋值，构造操作默认的都是拷贝，也就是说，我们会把一个值的资源拷贝一份，到新的值中，这样的做法很保险，因为你不知道旧的值之后还会不会用上，但是性能很慢，对于一些临时的变量，实际上没必要进行移动，因为它们不会再被使用到了，我们可以把里面的资源直接移动到新值里。我们这种临时的值的这种特性，称之为**可移动的**。

当然，函数的返回值也是一个右值，因为它是一个临时值：
```C++
struct Foo{

};

Foo func(){
    return Foo{};
}
```
我们可以列出这么一个表格：
|      | 有实体 | 可移动 |
| ---- | ---- | ---- |
| 左值 | 是 | 否 |
| 右值 | 否 | 是 |

到目前为止，还是比较容易理解，我们只需要对右值进行移动赋值/构造，对左值进行拷贝赋值/构造即可。

## 移动语义催生下的新的值分类体系

但是我们可以举一些反例，比如说我们要让函数返回两个int变量，所以我们把它们放入我们刚才举的结构体：
```c++

struct Foo{
    int x, y;
};

Foo func(){
    return Foo{};
}

int main(){
    int tmp = func().x;
}
```
此时就出现争议了，按照我们的标准，这个函数的返回值，应该是左值还是右值呢？如果你说它是右值，因为它是一个临时变量，但是它必须得占一部分内存空间来存储x和y，它不能直接保存在寄存器中，所以它有实体，但是如果你是说它是一个左值，它又是一个临时变量，所以可以看到，此时的返回值，实际上既有实体，又是可移动的。

再举一个例子，我们知道，const引用可以使得被引用的值的生命周期延长，比如说我们有一个普通的int：
```C++
int x = 1;
```
它的生命周期在执行完这个语句之后就结束了，但是我们给它加一个const引用：
```C++
const int& ref = 1;
```
我们就延长了1的生命周期，此时1就是有实体的了，不可能存在于寄存器中，所以此时，这个1也是既有实体，又是临时的值，是可移动的。

对于这种值，我们给它们取一个名字，因为它的生命周期要结束了，但是和真正的右值比起来，还是没有完全结束，所以就叫它将亡值，现在我们不仅有左值和右值，还有将亡值：

|        | 有实体 | 可移动 |
| ----   | ----  | ----   |
| 左值   | 是     | 否     |
| 右值   | 否     | 是     |
| 将亡值 | 是     | 是     |

但是我们的移动语义，只认可不可移动，它不是因为右值才移动，是因为右值是个临时值，所以才移动，或者说，右值的定义，可能就是指那些临时的值，可移动的值，而左值的定义，就是指那些有实体的值，他们俩是不冲突的，这一点在将亡值身上就体现得很好。

但是如果把右值和将亡值叫右值，那么两个右值就互相包含了，发生了矛盾，既然左值是指有实体的指，那么将亡值也应该是是左值，所以左值等于左值加将亡值，但是这里的左值又互相冲突了，为了解决这个冲突，我们有一个标准，那就是能被移动语义优化的，就叫右值，不能被移动语义优化的，就叫左值，这可以方便我们接下来定义拷贝/移动赋值函数。

所以右值和将亡值是可以移动的，可以被移动语义优化，所以我们称之为右值，原来的右值改成纯右值，左值不能被移动语义优化，所以还是称之为左值，但是C++98里，关于左值的定义是有实体的值，所以左值和将亡值都称之为左值，但是这里冲突了，我们改成泛左值。

在讨论移动语义的过程中，我们很少讨论纯右值或者泛左值，而且我们没有必要定义应该纯右值引用/泛左值引用这样的东西在，这就是这套值分类体系给我们带来的好处。

## 右值引用

我们知道，在C++中，我们是支持自定义拷贝赋值和拷贝构造的，那么现在引入了移动语义，我们也应该支持自定义的移动赋值和移动构造。

我们先来看看拷贝赋值是怎么实现的，我们需要定义一个赋值运算符：
```C++
class Demo{
    public:
        Demo& operator=(const Demo& demo){
            //
        }
};
```

我们传入的是要拷贝的Demo的引用，这样可以在参数传递的过程中，减少重新构造Demo的开销，因为我们不需要修改原对象，所以我们加一个const。

此时我们要加入一个新的赋值运算符函数，这两个函数是同时存在的，那么摆在面前的第一个问题，就是我怎么知道值应该去哪一个函数呢？我们知道，我们会对左值执行拷贝，对右值执行移动，所以我们只需要定义一种独属于右值的引用就可以了，左值引用是&，那么我们就把右值引用定义成&&，然后我们是要移动原值的数据，所以会对原值进行修改，所以就没办法加const了，所以移动的赋值运算符应该是这样的：

```C++
class Demo{
    public:
        Demo& operator=(Demo&& demo){
            //
        }
};
```

## std::move

我们之所以说，让右值进行移动语义优化，是因为右值是临时的值，进行移动不会有问题，这是对编译器来说的，但是有一些值，对于程序员来说，它虽然不是临时值，但是也可以进行移动优化，因为以后可能用不上了。

比如说，我们需要把v1赋值给v2，但是v1我们不用了，我们就可以把v1用std::move修饰一下，它原来是不能被移动的左值，现在std::move输出的是右值，它就可以被匹配到移动赋值函数里：

```C++
vector<int> v1 = {1, 2,3};
// some statements

vector<int> v2;

v2 = std::move(v1);
```
此时你输出v1的值，就会出现段错误：
```C++
vector<int> v1 = {1, 2,3};
// some statements

vector<int> v2;

v2 = std::move(v1);

// Segmentation fault  (core dumped)
std::cout << v1[0];
```

所以std::move相当于C++相信，程序员比编译器更懂代码，更应该知道哪里需要进行优化，以进一步提升性能。

从实现上来说，首先，我们要把一个值转换成一个右值，我们就直接把它的值类型去掉，因为不管是右值还是左值，都需要转换为右值：

```C++
template <class T>
typename remove_reference<T>::type&& move(T&& t) noexcept {
        using return_type = typename remove_reference<T>::type;
        return static_cast<return_type>(t);
}
```
然后，变成右值引用，也就是&&：
```C++
template <class T>
typename remove_reference<T>::type&& move(T&& t) noexcept {
        using return_type = typename remove_reference<T>::type;
        return static_cast<return_type>(t);
}
```
## 完美转发

我们因为要进行移动语义，所以引入了右值引用，使得右值可以和左值匹配到不同的函数，但是右值引用的加入使得C++原有的体系的其它部分出现了一些问题，主要问题有：

1. 函数参数转发能力减弱
2. 可能会产生多级引用
3. 右值引用也是一个左值

所以接下来算是填坑吧。
### 函数转发能力减弱

因为左右值有自己的引用，所以我们必须写两个函数来匹配值，对于这个问题，我们可以用const引用来缓解，因为const引用可以同时匹配左右值引用：

```C++
void func(const int& v){

}

int main(){
    func(1);
    int x = 1;
    func(x);
}
```
但是因为有const的存在，func函数转发后就不能修改v了。

### 右值引用是一个左值
这会导致作为右值的实参在传入匹配到的函数后，变成了左值，出现了失真，我们就不能对右值进行移动了，所以我们希望在函数参数传递的过程中，保留值的左右值的特性。
### 模板引用导致多级引用

用模板来做函数的形参有一个好处，那就是可以真正实现万能引用，T&&既可以接左值引用也可以接右值引用，用这种方法可以解决上面提到的问题：

```C++
void func(T&& v){

}

int main(){
    func(1);
    int x = 1;
    func(x);
}
```

但是使用模板类型做参数的时候，可能会产生多级引用，比如说T&&，其中T是一个右值引用int&&，那么T&&经过推导后就变成了int&&&&。我们可以设计一种折叠机制，把多的，没有意义的&折叠成一个或者两个&，一个&就是左值引用，两个&的就是右值引用。

那么究竟应该怎么折叠呢？int&&&&应该折叠成int&还是int&&呢？这和我们提到的第二点问题有关系，我们希望，如果v是一个右值，那么它应该被折叠成右值引用，比如说T是int&&,展开后就变成int&&&&，我们就希望它最后折叠成int&&,如果T是int&,展开后变成int&&&,最后我们希望它折叠成int&，所以折叠规则就是：

| 折叠前  | 折叠后 |
| ----   | ----  |
| T&&&&   | T&&   |
| T&&&   | T&     |

有了这套规则我们就可以把一个右值引用从左值还原回右值了

## std::forward的实现

在上面的介绍中，我们发现std::move可以把任意一个值转换为一个右值，std::forward可以把输入的值还原回它本来的值类型，那么它是怎么实现的呢？那就需要用到我们之前说的引用折叠了。我们只需要在T前面加上&&，发生引用折叠后就会变成原来的引用类型：

```C++
template <class T>
T&& forward(typename tinySTL::remove_reference<T>::type&& t) noexcept {
    return static_cast<T&&>(t);
}
```
但是这个只会匹配右值，左值也得来一个，不然找不到函数
```C++
template <class T>
T&& forward(typename tinySTL::remove_reference<T>::type& t) noexcept {
    return static_cast<T&&>(t);
}
```