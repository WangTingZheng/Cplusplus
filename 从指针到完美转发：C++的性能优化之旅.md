# 从右值到完美转发：C++的性能优化之旅

## 右值与左值

C++里的赋值，构造操作默认的都是拷贝，也就是说，我们会把一个值的资源拷贝一份，到新的值中，这样的做法很保险，因为你不知道旧的值之后还会不会用上，但是性能很慢，对于一些临时的变量，实际上没必要进行移动，因为它们不会再被使用到了，我们可以把里面的资源直接移动到新值里。我们这种临时的值的这种特性，称之为**可移动的**。

当然，函数的返回值也是一个右值，因为它是一个临时值：
```C++
struct Foo{

};

Foo func(){
    return Foo{};
}
```

在C++98里，我们使用**有没有实体**来区别左值与右值，像下面这种变量a，它实际上是在内存中有一个区域来存储它的，所以我们称之为左值，1是一个字面量，存在寄存器中，没有不算一个实体，因为没有独属于它的空间，这个寄存器随时可以存储下一个值，所以叫右值。
```c++
int a = 1;
```
所以左值可以取地址：

```c++
int *ptr = &a;
```
但是右值不行：
```c++
int *ptr = &1;
```
我们可以列出这么一个表格：
|      | 有实体 | 可移动 |
| ---- | ---- | ---- |
| 左值 | 是 | 否 |
| 右值 | 否 | 是 |
到目前为止，还是比较容易理解，我们只需要对右值进行移动赋值/构造，对左值进行拷贝赋值/构造即可。

但是我们可以举一些反例，比如说我们要让函数返回两个int变量，所以我们把它们放入我们刚才举的结构体：
```c++

struct Foo{
    int x, y;
};

Foo func(){
    return Foo{};
}

int main(){
    int tmp = func().x;
}
```
此时就出现争议了，按照我们的标准，这个函数的返回值，应该是左值还是右值呢？如果你说它是右值，因为它是一个临时变量，但是它必须得占一部分内存空间来存储x和y，它不能直接保存在寄存器中，所以它有实体，但是如果你是说它是一个左值，它又是一个临时变量，所以可以看到，此时的返回值，实际上既有实体，又是可移动的。

再举一个例子，我们知道，const引用可以使得被引用的值的生命周期延长，比如说我们有一个普通的int：
```C++
int x = 1;
```
它的生命周期在执行完这个语句之后就结束了，但是我们给它加一个const引用：
```C++
const int& ref = 1;
```
我们就延长了1的生命周期，此时1就是有实体的了，不可能存在于寄存器中，所以此时，这个1也是既有实体，又是临时的值，是可移动的。

对于这种值，我们给它们取一个名字，因为它的生命周期要结束了，但是和真正的右值比起来，还是没有完全结束，所以就叫它将亡值，现在我们不仅有左值和右值，还有将亡值：

|        | 有实体 | 可移动 |
| ----   | ----  | ----   |
| 左值   | 是     | 否     |
| 右值   | 否     | 是     |
| 将亡值 | 是     | 是     |

但是我们的移动语义，只认可不可移动，它不是因为右值才移动，是因为右值是个临时值，所以才移动，或者说，右值的定义，可能就是指那些临时的值，可移动的值，而左值的定义，就是指那些有实体的值，他们俩是不冲突的，这一点在将亡值身上就体现得很好。

但是如果把右值和将亡值叫右值，那么两个右值就互相包含了，发生了矛盾，既然左值是指有实体的指，那么将亡值也应该是是左值，所以左值等于左值加将亡值，但是这里的左值又互相冲突了，为了解决这个冲突，我们有一个标准，那就是能被移动语义优化的，就叫右值，不能被移动语义优化的，就叫左值，这可以方便我们接下来定义拷贝/移动赋值函数。

所以右值和将亡值是可以移动的，可以被移动语义优化，所以我们称之为右值，原来的右值改成纯右值，左值不能被移动语义优化，所以还是称之为左值，但是C++98里，关于左值的定义是有实体的值，所以左值和将亡值都称之为左值，但是这里冲突了，我们改成泛左值。

在讨论移动语义的过程中，我们很少讨论纯右值或者泛左值，而且我们没有必要定义应该纯右值引用/泛左值引用这样的东西在，这就是这套值分类体系给我们带来的好处。

## 右值引用

我们知道，在C++中，我们是支持自定义拷贝赋值和拷贝构造的，那么现在引入了移动语义，我们也应该支持自定义的移动赋值和移动构造。

我们先来看看拷贝赋值是怎么实现的，我们需要定义一个赋值运算符：
```C++
class Demo{
    public:
        Demo& operator=(const Demo& demo){
            //
        }
};
```

我们传入的是要拷贝的Demo的引用，这样可以在参数传递的过程中，减少重新构造Demo的开销，因为我们不需要修改原对象，所以我们加一个const。

此时我们要加入一个新的赋值运算符函数，这两个函数是同时存在的，那么摆在面前的第一个问题，就是我怎么知道值应该去哪一个函数呢？我们知道，我们会对左值执行拷贝，对右值执行移动，所以我们只需要定义一种独属于右值的引用就可以了，左值引用是&，那么我们就把右值引用定义成&&，然后我们是要移动原值的数据，所以会对原值进行修改，所以就没办法加const了，所以移动的赋值运算符应该是这样的：

```C++
class Demo{
    public:
        Demo& operator=(Demo&& demo){
            //
        }
};
```

## std::move



## 完美转发

### 函数参数转发能力减弱

### 模板引用导致多级引用

### 右值引用是一个左值

## 移动语义的实现