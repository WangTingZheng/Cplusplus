# 不同生命周期的对象

## 自由存储对象

很显然的一点是，我们可以使用new/delete直接在自由存储区申请内存来存放对象，这样的对象我们称之为自由存储对象。自由存储对象的生命周期完全由new/delete来控制，也就是由程序员来控制。

值得一提的是，这个自由存储区只是C++中的一种抽象概念，它和操作系统的堆并不是完全一样，自由存储区特指用new创建对象的区域，大多数编译器都使用malloc/free来创建堆中的内存区块，所以很多时候自由存储区就是堆，但是不排除有不使用malloc/free来实现new/delete的情况，标准草案里并没有明确规定这一点。

还有一点值得注意的是，如果new之后不进行delete，内存还是会在进程退出后被释放，所以内存泄漏的程序仍然可以运行，但是有可能会导致在程序运行的过程中，内存不够用的情况。所以我们需要尽可能地避免内存泄漏。

## 自动对象

在面向过程中，函数是对一个任务地封装，如果没有函数，你可能会把代码写得非常长，这样很难进行维护，因为人的精力是有限制的，就好比战场的指战员不能掌握全部信息进行决策，每个人都在各自的位置上发挥他们的作用。

有了函数，我们就可以把一个大任务封装成一个个任务，在维护的时候，我们只需要重点关注它们的调用关系即可，分工合作的时候，每个人也可以只负责一部分函数的实现。

没有特别说明的话，函数里的对象都是临时的，它们被创建起来完成一个小函数所定义的任务，任务完成后，它们就被释放了。它们在定义的地方被创建，在离开作用域（不一定函数函数结束后，但是函数结束后它们肯定不存在了）被销毁。

大多数实现中，自动对象被存放在栈空间中，每调用一次函数，我们都需要创建一个栈帧用来保存函数所用的自动对象，为什么要有栈呢？在函数递归的时候，在下层函数执行完返回的时候，需要恢复上层函数的栈帧，因为上层函数的栈帧是先创建的，但是是后弹出的，所以我们要用栈。

## 静态对象

但是在函数中，如果只有自动对象的话，会有问题，所有的对象都是临时的，对象就没办法在函数之间共享，我们当然可以用全局对象，但是全局变量太全局了，所有函数都可以调用，很多情况下，我只希望当前函数的多次调用共享某些对象，这似乎和friend class是类似的。

所以我们有了静态对象，静态对象是使用static修饰的对象，它保存在静态存储区，静态对象的特点是它不会随着函数的结束而被析构，而且只会初始化一次：

```c++
void f(int a){
    while(a--){
        static int n = 0; //只初始化一次
        int x = 0; // 每次调用f()都会初始化

        cout << "n ==" << n++ << ", x ==" << x++ << '\n';
    }
}

int main(){
    f(3);
}
```
n是一个static对象，n = 0的指令只会在第一次执行到这个地方的时候执行，while循环第二次运行的时候，就不会执行n = 0了，所以这段程序执行的结果是：

```c++
n == 0, x == 0
n == 1, x == 0
n == 2, x == 0
```
在LevelDB的变长编码中，有一个变量是固定的值128，它就没必要是一个自动对象，每次函数执行完就销毁，再次执行又初始化，初始化的又是同一个值：
```C++
char* EncodeVarint32(char* dst, uint32_t v) {
  // Operate on characters as unsigneds
  uint8_t* ptr = reinterpret_cast<uint8_t*>(dst);
  static const int B = 128;

  ...
}
```

## 线程局部对象

现在我们引入多线程，那么线程肯定得用到变量或者对象，我们此时有自由存储对象、自动对象、静态对象可以使用，对于自由存储对象，使用它的问题是，我们可能会在多个线程中使用指针共同操作一块内存，这是十分危险的。

对于自动对象来说，它是存储在栈空间的，而线程并不会有很多栈空间可以使用。

对于静态对象来说，它对于多线程来说是共享的，可能会发生数据竞争，这种情况比较难检测和解决，一个简单的方法是加锁，限制同一时刻，只有一个线程可以访问static对象，但是这会影响多线程的性能。

所以，C++创建了线程局部对象（thread local），它是独属于线程的对象，随着线程的创建而创建，随着线程的销毁而销毁。

从实现上来说，C++会为每一个线程创建一个独有的寄存器组，其中有一个fs寄存器会保存内存中的一块区域的地址，这个地址就是保存堆中的线程局部对象的地址，每个线程的thread local都有自己的内存地址，当发生线程切换时，我们可以通过切换fs的值，来访问不同的内存地址，来读取属于当前线程的thread local对象，因为thread local在线程之间并不共享，所以就没有数据竞争问题，算是一种以空间换时间的操作吧。

